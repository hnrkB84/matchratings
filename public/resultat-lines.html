<!DOCTYPE html>
<html lang="sv">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>HV71 – Resultat: Kedjor & PP1</title>
<style>
  :root{
    --hv-blue:#0a2240; --hv-yellow:#ffcb01; --ink:#e8eef6;
    --card:#0b1f3a; --card-strong:#0d1f3d; --muted:#9fb3d9;
    --bar:#3a64a8; --barTop:#ffcb01;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--hv-blue);color:var(--ink);font-family:system-ui,-apple-system,Inter,Roboto,Segoe UI,Helvetica,Arial,sans-serif}
  header{position:sticky;top:0;z-index:10;background:linear-gradient(180deg,#09203b 0%,#0a2240 100%);border-bottom:1px solid rgba(255,255,255,.06);padding:12px 14px 10px}
  h1{margin:0 0 2px;color:var(--hv-yellow);font-size:1.3rem}
  .sub{margin:0;color:#bdd1f6;font-weight:600;font-size:.95rem}
  .wrap{max-width:980px;margin:0 auto;padding:12px}

  .row{display:grid;gap:10px}
  @media(min-width:780px){.row.two{grid-template-columns:1fr 1fr}}
  @media(min-width:980px){.row.three{grid-template-columns:1fr 1fr 1fr}}
  .card{background:var(--card);border:1px solid rgba(255,255,255,.1);border-radius:14px;padding:12px;box-shadow:0 2px 0 rgba(0,0,0,.25)}
  .card h2{margin:0 0 8px;color:var(--hv-yellow);font-size:1.05rem}
  .meta{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .pill{display:inline-flex;align-items:center;gap:6px;background:#0f2d58;border:1px solid rgba(255,255,255,.12);color:#e8f0ff;border-radius:999px;padding:6px 10px;font-weight:800}
  .btn{border:none;cursor:pointer;border-radius:10px;font-weight:800}
  .btn.ghost{background:transparent;color:#cfe0ff;border:1px solid rgba(255,255,255,.16);padding:8px 10px}
  .switch{display:inline-flex;align-items:center;gap:8px}
  .switch input{transform:scale(1.2)}

  .grid-lines{display:grid;grid-template-columns:1fr;gap:10px}
  @media(min-width:760px){.grid-lines{grid-template-columns:1fr 1fr}}
  .line-card{background:var(--card-strong);border:1px solid rgba(255,255,255,.10);border-radius:12px;padding:10px}
  .line-title{margin:0 0 8px;color:#ffdc4d;font-weight:900}
  .pos-group{margin:8px 0 6px}
  .pos-title{margin:0 0 6px;font-weight:900;color:#eaf2ff}
  .leader{display:flex;align-items:center;gap:8px;margin-bottom:6px}
  .jersey{min-width:22px;height:22px;line-height:22px;text-align:center;background:var(--hv-yellow);color:#1c1500;border-radius:999px;font-weight:900;font-size:.78rem}
  .leader .name{font-weight:900}
  .bar{height:8px;background:var(--bar);border-radius:999px;position:relative;overflow:hidden}
  .bar>span{position:absolute;left:0;top:0;bottom:0;background:var(--barTop)}
  .small{font-size:.9rem;color:#cfe0ff}

  .top3{margin:4px 0 0 0;padding:0;list-style:none}
  .top3 li{display:flex;align-items:center;gap:8px;margin:4px 0}
  .top3 .pct{margin-left:auto;color:#cfe0ff;font-variant-numeric:tabular-nums}

  .pp-grid{display:grid;gap:10px}
  @media(min-width:760px){.pp-grid{grid-template-columns:repeat(5,1fr)}}
  .pp-role{background:var(--card-strong);border:1px solid rgba(255,255,255,.10);border-radius:12px;padding:10px}
  .pp-role h3{margin:0 0 6px;color:#ffdc4d;font-size:.95rem}
  .muted{color:#9fb3d9}

  .scratch-list li{display:flex;gap:8px;align-items:center;margin:4px 0}
  footer{opacity:.85;margin:16px 0 8px;font-size:.85rem;color:#a9c0e9}
</style>
</head>
<body>
  <header>
    <h1>Resultat – Kedjor & PP1</h1>
    <p class="sub">Live-sammanställning av röster</p>
  </header>

  <div class="wrap">
    <div class="card">
      <div class="meta">
        <span id="voteCount" class="pill">Röster: –</span>
        <span id="lastUpdated" class="pill">Uppdaterad: –</span>
        <button id="refreshBtn" class="btn ghost">Uppdatera</button>
        <label class="switch pill"><input id="autoChk" type="checkbox" /> Auto-refresh</label>
        <span id="scope" class="muted"></span>
      </div>
    </div>

    <div class="row">
      <div class="card">
        <h2>Kedjor</h2>
        <div id="lines" class="grid-lines"></div>
      </div>
    </div>

    <div class="row">
      <div class="card">
        <h2>PP1</h2>
        <div id="pp1" class="pp-grid"></div>
      </div>
    </div>

    <div class="row two">
      <div class="card">
        <h2>Oanvända forwards (scratch)</h2>
        <ul id="scratch" class="scratch-list"></ul>
        <p class="muted small" id="scratchNote">Visas om rådata innehåller scratch-val.</p>
      </div>
      <div class="card">
        <h2>Teknik</h2>
        <p class="muted small">Denna vy försöker först hämta aggregerade resultat. Om servern istället ger råa röster (t.ex. <code>{ count, votes:[{payload_json:...}] }</code>) summeras de i webbläsaren.</p>
      </div>
    </div>

    <footer>HV-tema ©</footer>
  </div>

<script>
(() => {
  // ===== URL & scope =====
  const qp = new URLSearchParams(location.search);
  const matchId = qp.get('match') || null; // stöder ev. äldre länkning
  const scopeEl = document.getElementById('scope');
  scopeEl.textContent = matchId ? `(match ${matchId})` : '(stand-alone)';

  // ===== Elements =====
  const linesEl   = document.getElementById('lines');
  const ppEl      = document.getElementById('pp1');
  const scratchEl = document.getElementById('scratch');
  const voteCountEl = document.getElementById('voteCount');
  const updatedEl   = document.getElementById('lastUpdated');
  const refreshBtn  = document.getElementById('refreshBtn');
  const autoChk     = document.getElementById('autoChk');

  // ===== Helpers =====
  const fmtPct = (x)=> (x*100).toFixed(0) + '%';
  const nowStr = ()=> new Date().toLocaleString();

  function blankAgg(){
    return {
      total_votes: 0,
      players: {}, // id -> {name, jersey, pos}
      lines: { '1':{LW:{},C:{},RW:{}}, '2':{LW:{},C:{},RW:{}}, '3':{LW:{},C:{},RW:{}}, '4':{LW:{},C:{},RW:{}} },
      pp1:   { PNT:{}, LFL:{}, BUM:{}, RFL:{}, NET:{} },
      scratch: {} // id -> count
    };
  }

  function ensurePlayer(map, p){
    if(!p || !p.id) return;
    if(!map[p.id]) map[p.id] = { id:p.id, name:p.name, jersey:p.jersey, pos:p.position || p.pos || '?' };
  }

  // ---- Server svar -> normaliserad struktur ----
  // Format som stöds:
  //  A) Stand-alone (från /api/lines-results):
  //     { count:<n>, votes:[ { id, anon_fingerprint, payload_json:'{"lines":...,"pp1":...,"scratch":[...]}' } ] }
  //  B) Aggregat:
  //     { total_votes, players, lines:{...}, pp1:{...}, scratch? }
  //  C) Rå utan omslag: { votes:[ {lines, pp1, scratch} ] }
  function normalizeResponse(data){
    // B) redan aggregerat
    if (data && data.total_votes !== undefined && data.lines && data.pp1) {
      return data;
    }
    if (data && data.counts && data.players) {
      const A = blankAgg();
      A.total_votes = data.counts.total_votes ?? 0;
      A.players = data.players || {};
      A.lines   = data.counts.lines || A.lines;
      A.pp1     = data.counts.pp1   || A.pp1;
      if (data.scratch) A.scratch = data.scratch;
      return A;
    }

    // A/C) aggregera i klient
    return aggregateFromRaw(data);
  }

  function aggregateFromRaw(raw){
    const A = blankAgg();

    // Om servern skickar {count, votes:[rows]}
    let votes = [];
    if (raw && Array.isArray(raw.votes)) {
      // Rader kan innehålla payload_json (string). Mappa till rena objekt.
      votes = raw.votes.map(row => {
        if (row && typeof row.payload_json === 'string') {
          try { return JSON.parse(row.payload_json); }
          catch { return null; }
        }
        // Eller redan objekt (lines, pp1, scratch)
        return row || null;
      }).filter(Boolean);
    } else if (raw && Array.isArray(raw)) {
      votes = raw; // redan array
    } else if (raw && raw.lines && raw.pp1) {
      votes = [raw];
    }

    A.total_votes = votes.length;

    for (const v of votes) {
      // lines
      if (v.lines) {
        for (const L of ['1','2','3','4']) {
          const arr = v.lines[L] || [];
          for (const pick of arr) {
            if (!pick || !pick.id || !pick.pos) continue;
            ensurePlayer(A.players, pick);
            A.lines[L][pick.pos] ??= {};
            A.lines[L][pick.pos][pick.id] = (A.lines[L][pick.pos][pick.id] || 0) + 1;
          }
        }
      }
      // pp1
      if (Array.isArray(v.pp1)) {
        for (const pick of v.pp1) {
          if (!pick || !pick.id || !pick.role) continue;
          ensurePlayer(A.players, pick);
          A.pp1[pick.role] ??= {};
          A.pp1[pick.role][pick.id] = (A.pp1[pick.role][pick.id] || 0) + 1;
        }
      }
      // scratch (valfritt)
      if (Array.isArray(v.scratch)) {
        for (const s of v.scratch) {
          if (!s || !s.id) continue;
          ensurePlayer(A.players, s);
          A.scratch[s.id] = (A.scratch[s.id] || 0) + 1;
        }
      }
    }
    return A;
  }

  // ===== Rendering =====
  function topN(countMap, players, n=3){
    const arr = Object.entries(countMap || {}).map(([id,c])=>({id, c, p:players[id]}));
    arr.sort((a,b)=>b.c-a.c);
    return arr.slice(0,n);
  }

  function renderBars(container, items, total){
    container.innerHTML = '';
    if (!items.length || total<=0) {
      container.innerHTML = '<div class="small muted">Inga röster än.</div>';
      return;
    }
    const leader = items[0];
    const leaderLine = document.createElement('div');
    leaderLine.className = 'leader';
    leaderLine.innerHTML = `
      <span class="jersey">${leader.p?.jersey ?? '?'}</span>
      <span class="name">${leader.p?.name ?? leader.id}</span>
      <span class="pct">${fmtPct(leader.c/total)}</span>
    `;
    container.appendChild(leaderLine);
    const bar = document.createElement('div'); bar.className='bar';
    const span = document.createElement('span'); span.style.width = (leader.c/total*100)+'%';
    bar.appendChild(span); container.appendChild(bar);

    const ul = document.createElement('ul'); ul.className='top3';
    items.forEach((it)=>{
      const li = document.createElement('li');
      li.innerHTML = `
        <span class="jersey">${it.p?.jersey ?? '?'}</span>
        <span>${it.p?.name ?? it.id}</span>
        <span class="pct">${fmtPct(it.c/total)}</span>
      `;
      ul.appendChild(li);
    });
    container.appendChild(ul);
  }

  function renderLines(A){
    linesEl.innerHTML='';
    for (const L of ['1','2','3','4']) {
      const card = document.createElement('div');
      card.className = 'line-card';
      card.innerHTML = `<p class="line-title">Kedja ${L}</p>`;
      ['LW','C','RW'].forEach(pos=>{
        const box = document.createElement('div');
        box.className = 'pos-group';
        box.innerHTML = `<p class="pos-title">${pos}</p>`;
        const holder = document.createElement('div');
        renderBars(holder, topN(A.lines[L][pos], A.players, 3), A.total_votes);
        box.appendChild(holder);
        card.appendChild(box);
      });
      linesEl.appendChild(card);
    }
  }

  function renderPP(A){
    ppEl.innerHTML='';
    const roles = ['PNT','LFL','BUM','RFL','NET'];
    roles.forEach(role=>{
      const r = document.createElement('div');
      r.className = 'pp-role';
      r.innerHTML = `<h3>${role}</h3>`;
      const holder = document.createElement('div');
      renderBars(holder, topN(A.pp1[role], A.players, 3), A.total_votes);
      r.appendChild(holder);
      ppEl.appendChild(r);
    });
  }

  function renderScratch(A){
    scratchEl.innerHTML='';
    const entries = Object.entries(A.scratch || {}).map(([id,c])=>({id,c,p:A.players[id]})).sort((a,b)=>b.c-a.c).slice(0,10);
    if (!entries.length) {
      scratchEl.innerHTML = '<li class="muted small">Ingen scratch-data tillgänglig.</li>';
      return;
    }
    for (const it of entries) {
      const li = document.createElement('li');
      li.innerHTML = `
        <span class="jersey">${it.p?.jersey ?? '?'}</span>
        <span>${it.p?.name ?? it.id}</span>
        <span class="pct">${it.c}×</span>
      `;
      scratchEl.appendChild(li);
    }
  }

  // ===== Fetch logic (med fallback) =====
  async function fetchResults(){
    const urls = [];
    if (matchId) {
      urls.push(`/api/match/${encodeURIComponent(matchId)}/lines-results`); // om du i framtiden vill segmentera per match
    } else {
      urls.push(`/api/lines-results`); // stand-alone primärt
      urls.push(`/api/match/current/lines-results`); // legacy fallback
    }
    let lastErr;
    for (const u of urls) {
      try{
        const r = await fetch(u, {cache:'no-store'});
        const data = await r.json();
        if(!r.ok) throw new Error(data?.error || `HTTP ${r.status}`);
        return data;
      }catch(e){ lastErr=e; }
    }
    throw lastErr || new Error('Ingen fungerande results-endpoint hittades');
  }

  async function refresh(){
    try{
      const raw = await fetchResults();
      const A = normalizeResponse(raw);

      voteCountEl.textContent = `Röster: ${A.total_votes}`;
      updatedEl.textContent   = `Uppdaterad: ${nowStr()}`;

      renderLines(A);
      renderPP(A);
      renderScratch(A);
    }catch(e){
      console.error(e);
      updatedEl.textContent = 'Uppdaterad: fel vid hämtning';
      linesEl.innerHTML = `<div class="small">Kunde inte hämta resultat: ${e.message}</div>`;
      ppEl.innerHTML    = '';
      scratchEl.innerHTML = '';
    }
  }

  // Init
  refresh();
  refreshBtn.addEventListener('click', refresh);

  // Auto refresh
  let timer = null;
  autoChk.addEventListener('change', ()=>{
    if (autoChk.checked) {
      timer = setInterval(refresh, 15000); // 15 s
    } else {
      clearInterval(timer); timer=null;
    }
  });
})();
</script>
</body>
</html>
